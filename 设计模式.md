# 设计模式：C++ version

快速了解设计模式以应对秋招的面试。

![设计模式学习路线 by 程序员鱼皮](https://pic.yupi.icu/1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%20by%20%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE-20250707135803772.png)

开放闭合原则：对扩展开放，对修改关闭；



## 创建型



## 结构型

如何使类与对象结合在一起形成一个更强大的结构。

### 适配器模式：兼容接口

STL的适配器： stack<int, vector<int>> st;  **模板编程**；

**将一个类的接口转换成客户端期望的另一个接口**;

加入你要使用的一个第三库的接口和你使用的系统定义接口不一样的话，使用适配器模式；

C++里面的两种适配器模式实现：

1. 多重继承
2. 使用组合的对象适配器

直接看代码例子：

```
// 多重继承
// AdapterInterface 代表需要适配的不兼容接口
class Interface: public SysInterface, private AdapterInterface
{
	...
}
// 对象适配器
class Interface: public SysInterface{
	void calc(int num){
		m_adapterInterface->calc(100,true);
	}
	
private:
	AdapterInterface* m_adapterInterface{nullptr};  // 用这个去适配
}
```



### 组合模式：树形接口

**将对象组合成树形结构以表示 “部分 - 整体” 的层次关系**，

用户需要用统一的接口去操作复合和单一的接口，最重要的是一般要具有树形结构才行，**类似文件系统或者XML的UI结构；**

例子：

低代码平台拖拽元素，所有的组件(复合和单节点)都可以拖拽和调整大小，只有小的单节点可以编辑文字；

组成：

1. 抽象组件接口；Component :公共的方法，不公共的方法为空
2. 各自实现这个抽象组件接口；

代码例子：

```
class ElementInterface{
	void drag(const QPoint& point) = 0;
    void resize(...) =0;
    void editText(){
   		throw std::runtime_error("override");
   	}
}

void PTag:public ElementInterface{
	void editText(){...}
	// 自己的特性
	void setFloat(){}
}

void WidgetContainer: public ElementInterface{
	// 类似QT的那些容器
	void drag(...){...} //所有的元素都要动
}


// 调用的时候
ElementInterface *element = "你传入的某个东西";
```

补充：

> 安全模式和透明模式：复习一下



### 装饰器模式：组合去替代继承

例子：

**有一个窗口类，然后需要一个带黑边的窗口，一个带滚动条的窗口，用什么设计模式比较好：**

1. 可以灵活组合不同装饰（例如一个窗口可以同时有黑边和滚动条）
2. 避免创建大量子类（如 BlackBorderWindow、ScrollableWindow、BlackBorderScrollableWindow 等）
3. 可以在运行时动态添加或移除装饰

**解释：**

这种模式通过创建一个包装对象（装饰器）来包裹原始对象，从而在保持原始对象完整性的同时扩展其功能。

1. 抽象组件：装饰器和基类的接口；
2. 基类接口类实现，装饰器接口类实现
3. 具体扩展的装饰器

**实现例子代码**：

```
class Window{
	...
};

class BasicWindow: public Window{...}

class WindowDecorator: public Window{
	WindowDecoratoe(Window* window)
}
class BorderDecorator: public WindowDecorator{...}
class ScrollDecorator: public WindowDecorator{...}

// 可以任意的组合
Window* customWindow = new ScrollDecorator(new BorderDecorator(new BasicWindow));
```



### 代理模式：添加中间层去作为代理

proxy的使用其实在vue里面常见，需要一个对象的变换引起另一个对象的更新变化；

C++ 的智能指针、RAII 机制等也体现了代理模式的思想，是日常开发中隐形的 “设计模式实践”。

**一个类作为另一个类的代理类；**

**为一个对象提供 “代理”（中间层），通过代理间接访问原对象，从而在访问过程中添加额外控制逻辑**

在不修改原对象代码的前提下，通过代理对象对原对象的访问进行 “增强” 或 “控制”。例如：远程服务器的本地代理（处理网络通信）、大对象的延迟加载代理（避免过早占用资源）、敏感操作的权限代理（检查访问权限）等。

**组成：**

1. 抽象接口;
2. 正式的对象；
3. 代理对象：持有正式对象的引用；

例子：图片延迟加载

以 “大型图片加载” 为例：真实图片（`RealImage`）加载耗时，代理（`ImageProxy`）可以先显示 “加载中”，只有当用户真正需要显示时才加载图片，避免资源浪费。

代码例子:

```c++
// 客户只依赖于抽象的主题：ImageInterface接口；
// 通过代理类去控制和访问真实类
class ImageInterface{
	
};

class RealImage: public ImageInterface{
public:
	void loadImage();
}

class ProxyImage: public ImageInterface{
	RealImage* m_realImage{nullptr};
	void loadImage(){
		m_realImage->loadImage();
	}
}
```



### 享元模式：共享内部状态降低内存消耗

将对象分为内部状态和外部状态；享元对象会共享很多的内部状态；

组成部分：

1. 抽象接口；
2. 享元具体实现；
3. 享元工厂
4. client



## 行为型