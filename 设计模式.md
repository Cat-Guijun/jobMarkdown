# 设计模式：C++ version

快速了解设计模式以应对秋招的面试。

![设计模式学习路线 by 程序员鱼皮](https://pic.yupi.icu/1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%20by%20%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE-20250707135803772.png)

开放闭合原则：对扩展开放，对修改关闭；

依赖倒置原则：上层不依赖于下层；



## 创建型

### 单例模式

TODO: 因为很熟悉了；

饿汉式：

### 工厂方法模式

传统的new的方式不满足开闭原则： 对开放允许，因为你是直接 new 一个具体的产品；

工厂方法模式的解决方案：引入 “工厂” 角色，由工厂负责创建产品，**客户端仅依赖 “抽象工厂” 和 “抽象产品”**，不直接接触具体类，从而解决耦合问题。

### 抽象工厂模式



## 结构型

如何使类与对象结合在一起形成一个更强大的结构。

### 适配器模式：兼容接口

STL的适配器： stack<int, vector<int>> st;  **模板编程**；

**将一个类的接口转换成客户端期望的另一个接口**;

加入你要使用的一个第三库的接口和你使用的系统定义接口不一样的话，使用适配器模式；

C++里面的两种适配器模式实现：

1. 多重继承
2. 使用组合的对象适配器

直接看代码例子：

```
// 多重继承
// AdapterInterface 代表需要适配的不兼容接口
class Interface: public SysInterface, private AdapterInterface
{
	...
}
// 对象适配器
class Interface: public SysInterface{
	void calc(int num){
		m_adapterInterface->calc(100,true);
	}
	
private:
	AdapterInterface* m_adapterInterface{nullptr};  // 用这个去适配
}
```



### 组合模式：树形接口

**将对象组合成树形结构以表示 “部分 - 整体” 的层次关系**，

用户需要用统一的接口去操作复合和单一的接口，最重要的是一般要具有树形结构才行，**类似文件系统或者XML的UI结构；**

例子：

低代码平台拖拽元素，所有的组件(复合和单节点)都可以拖拽和调整大小，只有小的单节点可以编辑文字；

组成：

1. 抽象组件接口；Component :公共的方法，不公共的方法为空
2. 各自实现这个抽象组件接口；

代码例子：

```
class ElementInterface{
	void drag(const QPoint& point) = 0;
    void resize(...) =0;
    void editText(){
   		throw std::runtime_error("override");
   	}
}

void PTag:public ElementInterface{
	void editText(){...}
	// 自己的特性
	void setFloat(){}
}

void WidgetContainer: public ElementInterface{
	// 类似QT的那些容器
	void drag(...){...} //所有的元素都要动
}


// 调用的时候
ElementInterface *element = "你传入的某个东西";
```

补充：

> 安全模式和透明模式：复习一下



### 装饰器模式：组合去替代继承

例子：

**有一个窗口类，然后需要一个带黑边的窗口，一个带滚动条的窗口，用什么设计模式比较好：**

1. 可以灵活组合不同装饰（例如一个窗口可以同时有黑边和滚动条）
2. 避免创建大量子类（如 BlackBorderWindow、ScrollableWindow、BlackBorderScrollableWindow 等）
3. 可以在运行时动态添加或移除装饰

**解释：**

这种模式通过创建一个包装对象（装饰器）来包裹原始对象，从而在保持原始对象完整性的同时扩展其功能。

1. 抽象组件：装饰器和基类的接口；
2. 基类接口类实现，装饰器接口类实现
3. 具体扩展的装饰器

**实现例子代码**：

```
class Window{
	...
};

class BasicWindow: public Window{...}

class WindowDecorator: public Window{
	WindowDecoratoe(Window* window)
}
class BorderDecorator: public WindowDecorator{...}
class ScrollDecorator: public WindowDecorator{...}

// 可以任意的组合
Window* customWindow = new ScrollDecorator(new BorderDecorator(new BasicWindow));
```



### 代理模式：添加中间层去作为代理

proxy的使用其实在vue里面常见，需要一个对象的变换引起另一个对象的更新变化；

C++ 的智能指针、RAII 机制等也体现了代理模式的思想，是日常开发中隐形的 “设计模式实践”。

**一个类作为另一个类的代理类；**

**为一个对象提供 “代理”（中间层），通过代理间接访问原对象，从而在访问过程中添加额外控制逻辑**

在不修改原对象代码的前提下，通过代理对象对原对象的访问进行 “增强” 或 “控制”。例如：远程服务器的本地代理（处理网络通信）、大对象的延迟加载代理（避免过早占用资源）、敏感操作的权限代理（检查访问权限）等。

**组成：**

1. 抽象接口;
2. 正式的对象；
3. 代理对象：持有正式对象的引用；

例子：图片延迟加载

以 “大型图片加载” 为例：真实图片（`RealImage`）加载耗时，代理（`ImageProxy`）可以先显示 “加载中”，只有当用户真正需要显示时才加载图片，避免资源浪费。

代码例子:

```c++
// 客户只依赖于抽象的主题：ImageInterface接口；
// 通过代理类去控制和访问真实类
class ImageInterface{
	
};

class RealImage: public ImageInterface{
public:
	void loadImage();
}

class ProxyImage: public ImageInterface{
	RealImage* m_realImage{nullptr};
	void loadImage(){
		m_realImage->loadImage();
	}
}
```



### 享元模式：共享内部状态降低内存消耗

将对象分为内部状态和外部状态；享元对象会共享很多的内部状态减少内存消耗；

通过工厂去创建内容（不是必须的）；但是很推荐；

组成部分：

1. 抽象接口；
2. 享元具体实现；
3. 享元工厂
4. client来控制外部状态的改变

例子：

在游戏常见下，需要渲染很多个子弹，但是子弹的贴图都是一样的，每次只有外部状态：x,y不同而已；贴图的大内存状态是可以共享的；

代码例子：

```
class Photo{
public:
	string filename;
	struct buffer[10000000000];
};

class BullPhoto: public Photo{
	...
};

class Factory{
	unordered_map<string,Photo*> _map;
	Photo* get(string filename){
		return _map[filename];
	}
}
```





### 外观模式：给复杂零碎的子系统提供一个整体的开关接口

外观类存在各个子系统对象的引用和指针；

**给复杂的子系统提供简洁统一的接口；**

例子：

一个智能家居系统，我离开家时，需要关闭电器系统和窗帘系统还有打开监控系统等，很麻烦；到家时又需要做一系列的操作；

很繁琐的操作就准备一个外观类；

**代码例子**：

```
class SmartSystem{
  Chuanglian* cl;
  dianji* cl2;
  ...
  void leaveRoom(){
  	cl.off();
  	cl2.off();
  	cl3.on();
  }
}
```



### 桥接模式：系统中存在多个独立维度时，使用桥接模式嫁接起来多个维度之前的关系

多个独立维度之前使用+法，而不是x法；**使用组合去替代继承，避免出现很多继承的问题；**

例子：

要画一个UI系统，他有shape和color两个维度的属性，要是使用继承的话，类是会出现乘法的关系；使用桥接模式来变成+法；

组成维度：

1. shape的接口，color的接口；
2. shape的接口中带有指向color的指针*；
3. 派生于shape的类，只需要带有不同的color指针就可以了；

代码实现：

```
class ColorInterface{
	enum color;	
}

class Red: public ColorInterface{
	...
}

class ShapeInterface{
	ColorInterface *m_color;
	...
	void drawShape();
}

class Circle: public ShapeInterface{
	...
}

// 使用的时候改变m_color的指向就可以了
```





## 行为型

