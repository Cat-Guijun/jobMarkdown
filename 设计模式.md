# 设计模式：C++ version

快速了解设计模式以应对秋招的面试： 面向接口去编程实现；

![设计模式学习路线 by 程序员鱼皮](https://pic.yupi.icu/1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%20by%20%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE-20250707135803772.png)

开放闭合原则：对扩展开放，对修改关闭；

依赖倒置原则：上层不依赖于下层；面向接口编程；

>依赖倒置原则的本质是 **“面向抽象编程”**：用抽象（接口 / 抽象类）定义系统的稳定骨架，让易变的细节（具体实现）依赖于稳定的抽象。它是设计模式（如工厂模式、策略模式、桥接模式）的核心思想，也是构建灵活、可扩展系统的基础。



## 创建型

### 单例模式

TODO: 因为很熟悉了；

饿汉式：

### 工厂方法模式

>简单工厂是就一个工厂，通过if-else去区分

传统的new的方式不满足开闭原则： 对开放允许，因为你是直接 new 一个具体的产品；

new FileLog   比较死板，因为做成 new ConsoleLog 必须修改代码，这里要做到的是 AbstractProduct *product =  ProductFactory->createFactoy();

工厂方法模式的解决方案：引入 “工厂” 角色，由工厂负责创建产品，**客户端仅依赖 “抽象工厂” 和 “抽象产品”**，不直接接触具体类，从而解决耦合问题。

代码例子：一个产品簇；

```
class FactoryInterface{
public:
	...
};
class ProductInterface(){
public:
	...
}


#include <iostream>
#include <string>
#include <memory>

// 1. 抽象产品：日志记录器（定义产品接口）
class Logger {
public:
    virtual ~Logger() = default;
    // 产品的核心功能：记录日志
    virtual void log(const std::string& message) const = 0;
};

// 具体产品1：文件日志记录器
class FileLogger : public Logger {
public:
    void log(const std::string& message) const override {
        std::cout << "[文件日志] " << message << "（已写入 log.txt）" << std::endl;
    }
};

// 具体产品2：控制台日志记录器
class ConsoleLogger : public Logger {
public:
    void log(const std::string& message) const override {
        std::cout << "[控制台日志] " << message << std::endl;
    }
};

// 2. 抽象工厂：日志工厂（定义创建产品的接口）
class LoggerFactory {
public:
    virtual ~LoggerFactory() = default;
    // 工厂方法：创建日志记录器（返回抽象产品类型）
    virtual std::unique_ptr<Logger> createLogger() const = 0;
};

// 具体工厂1：文件日志工厂（创建 FileLogger）
class FileLoggerFactory : public LoggerFactory {
public:
    std::unique_ptr<Logger> createLogger() const override {
        // 具体产品的创建逻辑封装在此处
        return std::make_unique<FileLogger>();
    }
};

// 具体工厂2：控制台日志工厂（创建 ConsoleLogger）
class ConsoleLoggerFactory : public LoggerFactory {
public:
    std::unique_ptr<Logger> createLogger() const override {
        return std::make_unique<ConsoleLogger>();
    }
};

// 3. 客户端代码（仅依赖抽象工厂和抽象产品，不接触具体类）
void clientCode(const LoggerFactory& factory) {
    // 1. 通过工厂创建产品（客户端不知道具体是 FileLogger 还是 ConsoleLogger）
    std::unique_ptr<Logger> logger = factory.createLogger();
    // 2. 使用产品功能（依赖抽象产品的接口）
    logger->log("系统启动成功");
    logger->log("用户登录：admin");
}

// 主函数：演示不同工厂的使用
int main() {
    std::cout << "=== 使用文件日志工厂 ===" << std::endl;
    FileLoggerFactory fileFactory;
    clientCode(fileFactory); // 客户端无需修改，只需更换工厂

    std::cout << "\n=== 使用控制台日志工厂 ===" << std::endl;
    ConsoleLoggerFactory consoleFactory;
    clientCode(consoleFactory);

    // 新增需求：数据库日志 → 只需新增 DatabaseLogger（具体产品）和 DatabaseLoggerFactory（具体工厂）
    // 客户端代码无需修改，直接传入 DatabaseLoggerFactory 即可
    return 0;
}
```



### 抽象工厂模式

多个产品簇，并且一个产品簇直接需要匹配的情况：

>当系统中存在**多个 “产品族”**（每个产品族包含一组相关产品），且需要确保同一产品族的产品相互匹配时，简单工厂或工厂方法模式会显得繁琐。例如：
>
>
>
>- 场景：UI 组件库需要支持 “Windows 风格” 和 “Mac 风格” 两个产品族，每个产品族包含 “按钮（Button）” 和 “文本框（TextBox）” 两个相关产品。
>- 需求：Windows 风格的按钮必须搭配 Windows 风格的文本框，不能混合 Mac 风格的组件。

抽象工厂是一个工厂会产生一簇产品，而工厂模式是一个工厂只会产出单一的产品；

代码例子：按照上面的UI组件库来组织代码；

```C++
// 产品的接口
class Text{};
class Button{};

class WinText: public Text{};
class WindButton:public Button{};

class MacText: public Text{};
class MacButton: public Button{};


class UIFactory{};
class WinFactory: public UIFactory{};
class MacFactory: publc UIFactory{
	creatText();
	creatButton();   // 抽象工厂有多个方法,而工厂模式就一个;
}
```



### 建造者模式：控制多个组件的生成和构建顺序

为什么要出现这个模式：new的方式为啥不行，参数太多了，不好控制；

组成部分：

1. 产品
2. 创建者： 抽象创建者（接口），具体创建者
3. 指挥者，用户代码通过指挥者来定义构建流程；Diretor中用户传入不同的builder来创建出不同的产品；

例子：

以组装一台电脑为例子，可能是需要建造出不同的入门电脑/游戏电脑；但是构建顺序是一样的只是，具体的组件不同而已；

**代码例子**

```
class Computer{
	void setCpu
	void setGPU
	void setCache
};

class BuilderInterface{
	Computer* m_computer;
	void buildCpu();
	void buildGPU();
	void buildCache();
};

class GameBuilder{
public:
	... 
};

// 给Diretor传入不同的Builder即可；

class ComputerDirector{
public:
	ComputerDirector(BuilderInterface* builder);
	
	void buildComputer(){
		buildCache();
		buildCpu();
		buildBoard();
	}
};
```

### 原型模式：拷贝

prototype：原型模式通常需要深拷贝

如果类对象的创建很消耗时间，比如使用new关键字的话, 这种需要用原型模式，从原型对象复制clone出新的对象；

与享元很相似；它是处理 “高成本对象创建” 和 “大量相似对象生成” 的最佳方案，也是很多框架（如 Qt 的`QObject::clone()`）中常用的设计模式。

组成：

1. 抽象接口
2. 具体类实现接口

**例子:**

在游戏开发过程中，我们设计出士兵，创建很多的士兵的话，假设士兵的初始化消耗很大；其实也就是说设计好**拷贝构造函数**；

代码例子：

```
class Guarder{
	Guarder(){
		// 创建很耗时
	}
	Guarder(const Guarder& guard){
		// 设计好拷贝构造函数
	}
};



// 1. 抽象原型：角色原型（定义克隆接口）
class CharacterPrototype {
public:
    virtual ~CharacterPrototype() = default;
    // 克隆方法：返回自身的拷贝（关键接口）
    virtual std::unique_ptr<CharacterPrototype> clone() const = 0;
    // 纯虚函数：展示角色信息（产品接口）
    virtual void showInfo() const = 0;
    // 设置位置（示例：克隆后可修改的属性）
    virtual void setPosition(int x, int y) = 0;
};


// 实现好接口
class Guarder: public CharacterPrototype{
    // like this 
    std::unique_ptr<CharacterPrototype> clone() const override {
    // 返回当前对象的深拷贝（使用拷贝构造函数）
    return std::make_unique<Warrior>(*this);
}
}
```



## 结构型

如何使类与对象结合在一起形成一个更强大的结构。

### 适配器模式：兼容接口

STL的适配器： stack<int, vector<int>> st;  **模板编程**；

**将一个类的接口转换成客户端期望的另一个接口**;

加入你要使用的一个第三库的接口和你使用的系统定义接口不一样的话，使用适配器模式；

C++里面的两种适配器模式实现：

1. 多重继承
2. 使用组合的对象适配器

直接看代码例子：

```
// 多重继承
// AdapterInterface 代表需要适配的不兼容接口
class Interface: public SysInterface, private AdapterInterface
{
	...
}
// 对象适配器
class Interface: public SysInterface{
	void calc(int num){
		m_adapterInterface->calc(100,true);
	}
	
private:
	AdapterInterface* m_adapterInterface{nullptr};  // 用这个去适配
}
```



### 组合模式：树形接口

**将对象组合成树形结构以表示 “部分 - 整体” 的层次关系**，

用户需要用统一的接口去操作复合和单一的接口，最重要的是一般要具有树形结构才行，**类似文件系统或者XML的UI结构；**

例子：

低代码平台拖拽元素，所有的组件(复合和单节点)都可以拖拽和调整大小，只有小的单节点可以编辑文字；

组成：

1. 抽象组件接口；Component :公共的方法，不公共的方法为空
2. 各自实现这个抽象组件接口；

代码例子：

```
class ElementInterface{
	void drag(const QPoint& point) = 0;
    void resize(...) =0;
    void editText(){
   		throw std::runtime_error("override");
   	}
}

void PTag:public ElementInterface{
	void editText(){...}
	// 自己的特性
	void setFloat(){}
}

void WidgetContainer: public ElementInterface{
	// 类似QT的那些容器
	void drag(...){...} //所有的元素都要动
}


// 调用的时候
ElementInterface *element = "你传入的某个东西";
```

补充：

> 安全模式和透明模式：复习一下



### 装饰器模式：组合去替代继承

例子：

**有一个窗口类，然后需要一个带黑边的窗口，一个带滚动条的窗口，用什么设计模式比较好：**

1. 可以灵活组合不同装饰（例如一个窗口可以同时有黑边和滚动条）
2. 避免创建大量子类（如 BlackBorderWindow、ScrollableWindow、BlackBorderScrollableWindow 等）
3. 可以在运行时动态添加或移除装饰

**解释：**

这种模式通过创建一个包装对象（装饰器）来包裹原始对象，从而在保持原始对象完整性的同时扩展其功能。

1. 抽象组件：装饰器和基类的接口；
2. 基类接口类实现，装饰器接口类实现
3. 具体扩展的装饰器

**实现例子代码**：

```
class Window{
	...
};

class BasicWindow: public Window{...}

class WindowDecorator: public Window{
	WindowDecoratoe(Window* window)
}
class BorderDecorator: public WindowDecorator{...}
class ScrollDecorator: public WindowDecorator{...}

// 可以任意的组合
Window* customWindow = new ScrollDecorator(new BorderDecorator(new BasicWindow));
```



### 代理模式：添加中间层去作为代理

proxy的使用其实在vue里面常见，需要一个对象的变换引起另一个对象的更新变化；

C++ 的智能指针、RAII 机制等也体现了代理模式的思想，是日常开发中隐形的 “设计模式实践”。

**一个类作为另一个类的代理类；**

**为一个对象提供 “代理”（中间层），通过代理间接访问原对象，从而在访问过程中添加额外控制逻辑**

在不修改原对象代码的前提下，通过代理对象对原对象的访问进行 “增强” 或 “控制”。例如：远程服务器的本地代理（处理网络通信）、大对象的延迟加载代理（避免过早占用资源）、敏感操作的权限代理（检查访问权限）等。

**组成：**

1. 抽象接口;
2. 正式的对象；
3. 代理对象：持有正式对象的引用；

例子：图片延迟加载

以 “大型图片加载” 为例：真实图片（`RealImage`）加载耗时，代理（`ImageProxy`）可以先显示 “加载中”，只有当用户真正需要显示时才加载图片，避免资源浪费。

代码例子:

```c++
// 客户只依赖于抽象的主题：ImageInterface接口；
// 通过代理类去控制和访问真实类
class ImageInterface{
	
};

class RealImage: public ImageInterface{
public:
	void loadImage();
}

class ProxyImage: public ImageInterface{
	RealImage* m_realImage{nullptr};
	void loadImage(){
		m_realImage->loadImage();
	}
}
```



### 享元模式：共享内部状态降低内存消耗

将对象分为内部状态和外部状态；享元对象会共享很多的内部状态减少内存消耗；

通过工厂去创建内容（不是必须的）；但是很推荐；

组成部分：

1. 抽象接口；
2. 享元具体实现；
3. 享元工厂
4. client来控制外部状态的改变

例子：

在游戏常见下，需要渲染很多个子弹，但是子弹的贴图都是一样的，每次只有外部状态：x,y不同而已；贴图的大内存状态是可以共享的；

代码例子：

```
class Photo{
public:
	string filename;
	struct buffer[10000000000];
};

class BullPhoto: public Photo{
	...
};

class Factory{
	unordered_map<string,Photo*> _map;
	Photo* get(string filename){
		return _map[filename];
	}
}
```





### 外观模式：给复杂零碎的子系统提供一个整体的开关接口

外观类存在各个子系统对象的引用和指针；

**给复杂的子系统提供简洁统一的接口；**

例子：

一个智能家居系统，我离开家时，需要关闭电器系统和窗帘系统还有打开监控系统等，很麻烦；到家时又需要做一系列的操作；

很繁琐的操作就准备一个外观类；

**代码例子**：

```
class SmartSystem{
  Chuanglian* cl;
  dianji* cl2;
  ...
  void leaveRoom(){
  	cl.off();
  	cl2.off();
  	cl3.on();
  }
}
```



### 桥接模式：系统中存在多个独立维度时，使用桥接模式嫁接起来多个维度之前的关系

多个独立维度之前使用+法，而不是x法；**使用组合去替代继承，避免出现很多继承的问题；**

例子：

要画一个UI系统，他有shape和color两个维度的属性，要是使用继承的话，类是会出现乘法的关系；使用桥接模式来变成+法；

组成维度：

1. shape的接口，color的接口；
2. shape的接口中带有指向color的指针*；
3. 派生于shape的类，只需要带有不同的color指针就可以了；

代码实现：

```
class ColorInterface{
	enum color;	
}

class Red: public ColorInterface{
	...
}

class ShapeInterface{
	ColorInterface *m_color;
	...
	void drawShape();
}

class Circle: public ShapeInterface{
	...
}

// 使用的时候改变m_color的指向就可以了
```





## 行为型

可以思考为MVC模式的一系列行为；

### 迭代器模式：单一职责原则，实现一个统一的接口去遍历集合中的元素

STL中的迭代器思想非常明显了；不同的容器使用**同样的接口**；要把类内部的实现封装起来；

组合

1. 类提供创建迭代器的方法；
2. 抽象迭代器接口和具体迭代器；

直接来代码例子:

```
class Iterator{};

class ListIterator: public Iterator{
public:
	xxxx
};


class AbsAggregate{
	Iterator* getIterator();
};

class Aggregate: public AbsAggregate{
	Iterator* getIterator();  // 返回一个符合当前容器的迭代器;
};
```



### 模板方法模式(类)

就是面向接口进行编程，定义一个base基类和派生类即可；

核心是： 抽象类定义出算法的流程逻辑，派生类定义出需要变换的逻辑方法，派生下虚函数即可；



### 策略模式：组合的方式定义很多的策略，策略在类的内部替换，避免if-else

大名鼎鼎的策略模式：各个算法流程之间是可以相互替换的；

策略模式需要满足单一职责原则；组成部分一般如下：

1. 抽象策略接口
2. 各种实现抽象策略接口的策略类；
3. 需要一个上下文来进行策略的转换，就算setStratege和 playment接口这样子

例子：

支付系统，你支付100块，可以用alipay 或者wechat pay；

代码例子：

```
class PayStratege{
 void pay(int amount)=0;
};

class WxPayStratege: public PayStratege{};
class AlipayStatege: public PayStratege{};

//策略切换的上下文
class PlaymentContex{
	std::unique_ptr<PayStratege> m_stratege;
	void setStrage(std::unique_ptr<PayStratege> strage);
	void pay(...){
		m_stratege->pay(..);
	}
}


```



### 命令模式：发送者和接收者解耦，发送者使用的是命令对象，命令对象持有接收者的引用；

看着信号与槽机制：

1. **支持命令的灵活管理**：命令对象可被存储（如在队列中）、传递（如跨线程发送）、组合（如宏命令：一键执行 “开灯光 + 开音响 + 调空调”）。
2. **轻松实现撤销 / 重做**：通过`undo()`方法记录反向操作，可实现多级撤销（如编辑器的 Ctrl+Z）。

组成部分：

1. Command接口；类似有execute/undo方法；
2. 派生出来的Command对象拥有他接收者的引用；例如LightOnCommand就拥有Light这个类；
3. 发送者通过command *类似的指针来进行execute方法的调用；

代码例子：

```
class Command{
public:
 	void exec()=0;
};

class LightComand: public Comamand{
	Light *m_light;
public:
	
};

class Sender{
	command* m_contant;
}
```

### 状态模式：状态改变时对应行为也会发生改变

状态的改变委托给的是状态对象自己，而不是上下文；  **思考下是不是更策略模式不一样；**

委托的意思就是上下文把自己的this指针会传递给状态对象；

**组成**：

1. state interface
2. 具体的state类
3. context上下文
4. 在state类中接受context进行上下文的转换操作；

代码例子：

```C++
#include <iostream>
#include <string>

// 前置声明：上下文类（电梯），供状态类访问
class Elevator;

// 1. 抽象状态：电梯状态接口
class ElevatorState {
public:
    virtual ~ElevatorState() = default;
    // 声明状态下的行为（参数为上下文，便于状态切换）
    virtual void openDoor(Elevator* elevator) = 0;
    virtual void closeDoor(Elevator* elevator) = 0;
    virtual void run(Elevator* elevator) = 0;
    virtual void stop(Elevator* elevator) = 0;
    virtual std::string getStateName() const = 0; // 获取状态名称（调试用）
};

// 2. 上下文：电梯（持有当前状态，委托行为）
class Elevator {
private:
    ElevatorState* currentState_; // 当前状态（由状态类控制切换）
public:
    // 初始化电梯为“停止”状态
    explicit Elevator(ElevatorState* initialState);

    // 提供给客户端的接口（委托给当前状态）
    void openDoor() {
        currentState_->openDoor(this);
    }

    void closeDoor() {
        currentState_->closeDoor(this);
    }

    void run() {
        currentState_->run(this);
    }

    void stop() {
        currentState_->stop(this);
    }

    // 供状态类调用，切换当前状态
    void setState(ElevatorState* newState) {
        currentState_ = newState;
        std::cout << "状态切换为：" << currentState_->getStateName() << std::endl;
    }

    // 获取当前状态（调试用）
    ElevatorState* getCurrentState() const {
        return currentState_;
    }
};

// 3. 具体状态：停止状态
class StoppedState : public ElevatorState {
public:
    void openDoor(Elevator* elevator) override {
        std::cout << "停止状态：执行开门..." << std::endl;
        // 切换到“开门”状态（假设已定义OpeningState实例）
        static OpeningState openingState;
        elevator->setState(&openingState);
    }

    void closeDoor(Elevator* elevator) override {
        std::cout << "停止状态：门已关闭，无需再关！" << std::endl;
    }

    void run(Elevator* elevator) override {
        std::cout << "停止状态：开始运行..." << std::endl;
        // 切换到“运行中”状态
        static RunningState runningState;
        elevator->setState(&runningState);
    }

    void stop(Elevator* elevator) override {
        std::cout << "停止状态：已停止，无需再停止！" << std::endl;
    }

    std::string getStateName() const override {
        return "停止";
    }
};

// 具体状态：运行中状态
class RunningState : public ElevatorState {
public:
    void openDoor(Elevator* elevator) override {
        std::cout << "运行中状态：禁止开门（危险）！" << std::endl;
    }

    void closeDoor(Elevator* elevator) override {
        std::cout << "运行中状态：门已关闭，无需再关！" << std::endl;
    }

    void run(Elevator* elevator) override {
        std::cout << "运行中状态：已在运行，无需再启动！" << std::endl;
    }

    void stop(Elevator* elevator) override {
        std::cout << "运行中状态：执行停止..." << std::endl;
        // 切换到“停止”状态
        static StoppedState stoppedState;
        elevator->setState(&stoppedState);
    }

    std::string getStateName() const override {
        return "运行中";
    }
};

// 具体状态：开门状态
class OpeningState : public ElevatorState {
public:
    void openDoor(Elevator* elevator) override {
        std::cout << "开门状态：门已打开，无需再开！" << std::endl;
    }

    void closeDoor(Elevator* elevator) override {
        std::cout << "开门状态：执行关门..." << std::endl;
        // 切换到“关门”状态
        static ClosingState closingState;
        elevator->setState(&closingState);
    }

    void run(Elevator* elevator) override {
        std::cout << "开门状态：门未关闭，无法运行！" << std::endl;
    }

    void stop(Elevator* elevator) override {
        std::cout << "开门状态：已停止，无需再停止！" << std::endl;
    }

    std::string getStateName() const override {
        return "开门";
    }
};

// 具体状态：关门状态
class ClosingState : public ElevatorState {
public:
    void openDoor(Elevator* elevator) override {
        std::cout << "关门状态：执行开门..." << std::endl;
        // 切换到“开门”状态
        static OpeningState openingState;
        elevator->setState(&openingState);
    }

    void closeDoor(Elevator* elevator) override {
        std::cout << "关门状态：门已关闭，无需再关！" << std::endl;
    }

    void run(Elevator* elevator) override {
        std::cout << "关门状态：开始运行..." << std::endl;
        // 切换到“运行中”状态
        static RunningState runningState;
        elevator->setState(&runningState);
    }

    void stop(Elevator* elevator) override {
        std::cout << "关门状态：执行停止..." << std::endl;
        // 切换到“停止”状态
        static StoppedState stoppedState;
        elevator->setState(&stoppedState);
    }

    std::string getStateName() const override {
        return "关门";
    }
};

// 初始化电梯的当前状态（停止状态）
Elevator::Elevator(ElevatorState* initialState) : currentState_(initialState) {
    std::cout << "电梯初始化，初始状态：" << currentState_->getStateName() << std::endl;
}

// 4. 客户端代码：操作电梯，观察状态变化
int main() {
    // 初始化状态实例（单例，避免重复创建）
    static StoppedState stoppedState;
    Elevator elevator(&stoppedState); // 电梯初始为停止状态

    std::cout << "\n=== 尝试开门 ===" << std::endl;
    elevator.openDoor(); // 停止状态 → 开门状态

    std::cout << "\n=== 尝试运行 ===" << std::endl;
    elevator.run(); // 开门状态 → 无法运行（提示错误）

    std::cout << "\n=== 尝试关门 ===" << std::endl;
    elevator.closeDoor(); // 开门状态 → 关门状态

    std::cout << "\n=== 尝试运行 ===" << std::endl;
    elevator.run(); // 关门状态 → 运行中状态

    std::cout << "\n=== 尝试开门 ===" << std::endl;
    elevator.openDoor(); // 运行中状态 → 禁止开门（提示错误）

    std::cout << "\n=== 尝试停止 ===" << std::endl;
    elevator.stop(); // 运行中状态 → 停止状态

    return 0;
}
```



### 责任链模式：把事件的接收者处理成一个责任链，上一个处理者决定是否传递给下一个处理者

类似于QT中的eventFilter之类的东西； return true，是否向后传递；

- **事件传递机制**：如 GUI 中的事件冒泡（点击按钮→面板→窗口依次处理事件）；

组成：

1. 责任链上面的接收者的接口：Approve
2. 定义Approve的具体接收者，需要设置例如setNext这种方法来保证链式性质
3. client要设置好责任链，然后调用第一个对象的函数即可；

代码例子:

```c++
#include <iostream>
#include <string>

// 1. 抽象处理者：审批者
class Approver {
protected:
    Approver* nextApprover_; // 下一个处理者（形成链）
    std::string name_;      // 处理者名称
public:
    explicit Approver(std::string name) : name_(std::move(name)), nextApprover_(nullptr) {}

    // 设置下一个处理者（支持链式调用）
    Approver* setNext(Approver* next) {
        nextApprover_ = next;
        return next; // 返回下一个处理者，便于连续设置（如a.setNext(b).setNext(c)）
    }

    // 抽象方法：处理请假请求（子类必须实现）
    virtual void approve(int days) = 0;

    virtual ~Approver() = default;
};

// 2. 具体处理者1：组长（处理≤1天的请假）
class TeamLeader : public Approver {
public:
    explicit TeamLeader(std::string name) : Approver(std::move(name)) {}

    void approve(int days) override {
        if (days <= 1) {
            std::cout << name_ << " 审批通过 " << days << " 天假期" << std::endl;
        } else if (nextApprover_) {
            // 无法处理，传递给下一个处理者
            std::cout << name_ << " 无法审批 " << days << " 天假期，转交给下一级..." << std::endl;
            nextApprover_->approve(days);
        } else {
            // 链尾，无人处理
            std::cout << name_ << " 无法审批，且无下一级处理者，审批失败！" << std::endl;
        }
    }
};

// 具体处理者2：经理（处理≤3天的请假）
class Manager : public Approver {
public:
    explicit Manager(std::string name) : Approver(std::move(name)) {}

    void approve(int days) override {
        if (days <= 3) {
            std::cout << name_ << " 审批通过 " << days << " 天假期" << std::endl;
        } else if (nextApprover_) {
            std::cout << name_ << " 无法审批 " << days << " 天假期，转交给下一级..." << std::endl;
            nextApprover_->approve(days);
        } else {
            std::cout << name_ << " 无法审批，且无下一级处理者，审批失败！" << std::endl;
        }
    }
};

// 具体处理者3：总监（处理≤7天的请假）
class Director : public Approver {
public:
    explicit Director(std::string name) : Approver(std::move(name)) {}

    void approve(int days) override {
        if (days <= 7) {
            std::cout << name_ << " 审批通过 " << days << " 天假期" << std::endl;
        } else if (nextApprover_) {
            std::cout << name_ << " 无法审批 " << days << " 天假期，转交给下一级..." << std::endl;
            nextApprover_->approve(days);
        } else {
            std::cout << name_ << " 无法审批（超过7天），且无下一级处理者，审批失败！" << std::endl;
        }
    }
};

// 3. 客户端代码：创建责任链并发起请求
int main() {
    // 创建具体处理者
    Approver* teamLeader = new TeamLeader("组长-张三");
    Approver* manager = new Manager("经理-李四");
    Approver* director = new Director("总监-王五");

    // 组装责任链：组长 → 经理 → 总监
    teamLeader->setNext(manager)->setNext(director);

    // 发起不同天数的请假请求（请求从链的起点进入）
    std::cout << "=== 请假1天 ===" << std::endl;
    teamLeader->approve(1);

    std::cout << "\n=== 请假2天 ===" << std::endl;
    teamLeader->approve(2);

    std::cout << "\n=== 请假5天 ===" << std::endl;
    teamLeader->approve(5);

    std::cout << "\n=== 请假10天 ===" << std::endl;
    teamLeader->approve(10);

    // 释放资源
    delete teamLeader;
    delete manager;
    delete director;
    return 0;
}
```



### 备忘录模式：保留封装性，不暴露类内部的结构

当需要保存对象的中间状态（如文本编辑器的历史记录、游戏存档、事务回滚）时;

组成部分：

1. 原生器 createMementor / 
2. 备忘录 设置原生器为friend class 
3. 管理者，拥有get/save

```
#include <iostream>
#include <string>
#include <vector>
#include <memory>

// 前置声明：原发器，供备忘录声明友元
class TextEditor;

// 1. 备忘录（Memento）：存储原发器状态，仅允许原发器访问
class EditorMemento {
private:
    std::string content_; // 存储的文本内容（原发器的内部状态）
    // 仅允许TextEditor访问私有成员（保证封装性）
    friend class TextEditor;

    // 私有构造器：只能由原发器创建
    explicit EditorMemento(std::string content) : content_(std::move(content)) {}

public:
    // 备忘录不提供修改状态的接口，确保状态不可变
    ~EditorMemento() = default;
};

// 2. 原发器（Originator）：文本编辑器，需要保存状态
class TextEditor {
private:
    std::string content_; // 当前文本内容（内部状态）

public:
    // 输入文本（修改状态）
    void type(const std::string& text) {
        content_ += text;
    }

    // 获取当前内容（仅用于展示，非必要）
    std::string getContent() const {
        return content_;
    }

    // 创建备忘录：保存当前状态
    std::unique_ptr<EditorMemento> createMemento() const {
        // 调用备忘录的私有构造器（因友元关系允许）
        return std::make_unique<EditorMemento>(content_);
    }

    // 从备忘录恢复状态
    void restoreFromMemento(const EditorMemento* memento) {
        if (memento) {
            content_ = memento->content_; // 访问备忘录的私有成员（因友元关系允许）
        }
    }
};

// 3. 管理者（Caretaker）：管理备忘录（历史记录）
class History {
private:
    std::vector<std::unique_ptr<EditorMemento>> mementos_; // 存储备忘录的列表

public:
    // 保存备忘录（记录当前状态）
    void saveMemento(std::unique_ptr<EditorMemento> memento) {
        mementos_.push_back(std::move(memento));
    }

    // 获取上一个备忘录（用于撤销）
    const EditorMemento* getLastMemento() const {
        if (mementos_.empty()) {
            return nullptr;
        }
        // 返回最后一个备忘录（不转移所有权，避免被删除）
        return mementos_.back().get();
    }

    // 移除最后一个备忘录（撤销后可选操作）
    void removeLastMemento() {
        if (!mementos_.empty()) {
            mementos_.pop_back();
        }
    }
};

// 4. 客户端代码：使用文本编辑器和撤销功能
int main() {
    // 创建原发器（文本编辑器）和管理者（历史记录）
    TextEditor editor;
    History history;

    // 场景1：输入文本并保存状态
    editor.type("Hello ");
    std::cout << "输入后内容：" << editor.getContent() << std::endl;
    history.saveMemento(editor.createMemento()); // 保存"Hello "

    // 场景2：继续输入并保存状态
    editor.type("World!");
    std::cout << "继续输入后内容：" << editor.getContent() << std::endl;
    history.saveMemento(editor.createMemento()); // 保存"Hello World!"

    // 场景3：撤销到上一步
    const EditorMemento* lastMemento = history.getLastMemento();
    if (lastMemento) {
        history.removeLastMemento(); // 移除当前状态的备忘录
        editor.restoreFromMemento(history.getLastMemento()); // 恢复到前一个状态
        std::cout << "撤销后内容：" << editor.getContent() << std::endl;
    }

    return 0;
}
```



### 观察者模式:public-subscribe , 当主题变化，观察这个主题的对象都变化；

- **UI 组件联动**：数据模型变化时，多个 UI 组件（如文本框、图表、列表）同步刷新（如 MVC 框架中的 View 观察 Model）；



观察者模式的解决方案：

- 主题仅维护 “观察者列表”，提供**注册 / 移除观察者**的接口，不关心观察者的具体实现；
- 观察者通过**统一接口**（如`update()`）响应主题的状态变化，无需知道其他观察者的存在；
- 当主题状态变化时，自动遍历观察者列表，调用其`update()`方法，实现 “广播式” 通知。



>subject {notify}  ->   observer{ update(subject*)}

其实你怎么看解耦没有呢，就算用多态和接口；

```
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <algorithm>

// 前置声明：主题，供观察者接口使用
class WeatherSubject;

// 1. 观察者（Observer）：抽象接口
class WeatherObserver {
public:
    virtual ~WeatherObserver() = default;
    // 接收通知的方法（参数为主题，便于获取最新状态）
    virtual void update(WeatherSubject* subject) = 0;
    // 获取观察者名称（调试用）
    virtual std::string getName() const = 0;
};

// 2. 主题（Subject）：抽象接口
class WeatherSubject {
protected:
    // 存储观察者列表（用智能指针避免内存泄漏）
    std::vector<std::shared_ptr<WeatherObserver>> observers_;

public:
    virtual ~WeatherSubject() = default;

    // 注册观察者
    void attach(std::shared_ptr<WeatherObserver> observer) {
        if (observer) {
            observers_.push_back(observer);
            std::cout << "注册观察者：" << observer->getName() << std::endl;
        }
    }

    // 移除观察者
    void detach(std::shared_ptr<WeatherObserver> observer) {
        if (!observer) return;
        auto it = std::find_if(observers_.begin(), observers_.end(),
            [&](const std::shared_ptr<WeatherObserver>& obs) {
                return obs->getName() == observer->getName();
            });
        if (it != observers_.end()) {
            std::cout << "移除观察者：" << observer->getName() << std::endl;
            observers_.erase(it);
        }
    }

    // 通知所有观察者（模板方法，子类可重写通知逻辑）
    virtual void notify() {
        std::cout << "\n=== 主题状态变化，通知所有观察者 ===" << std::endl;
        for (const auto& observer : observers_) {
            observer->update(this); // 调用观察者的更新方法
        }
    }

    // 抽象方法：获取主题的最新状态（供观察者调用）
    virtual float getTemperature() const = 0; // 温度
    virtual float getHumidity() const = 0;    // 湿度
    virtual std::string getWind() const = 0;  // 风力
};

// 3. 具体主题（ConcreteSubject）：天气数据中心
class WeatherDataCenter : public WeatherSubject {
private:
    float temperature_; // 当前温度
    float humidity_;    // 当前湿度
    std::string wind_;  // 当前风力

public:
    // 更新天气数据（触发通知）
    void setWeatherData(float temp, float humidity, const std::string& wind) {
        temperature_ = temp;
        humidity_ = humidity;
        wind_ = wind;
        std::cout << "\n天气数据更新：温度=" << temp << "℃，湿度=" << humidity << "%，风力=" << wind << std::endl;
        notify(); // 数据更新后，自动通知观察者
    }

    // 实现获取状态的方法（供观察者调用）
    float getTemperature() const override { return temperature_; }
    float getHumidity() const override { return humidity_; }
    std::string getWind() const override { return wind_; }
};

// 4. 具体观察者1：手机APP
class PhoneAPP : public WeatherObserver {
private:
    std::string name_;
public:
    explicit PhoneAPP(std::string name) : name_(std::move(name)) {}

    void update(WeatherSubject* subject) override {
        if (subject) {
            // 从主题获取最新数据并更新显示
            std::cout << "[" << name_ << "] 刷新天气："
                      << "温度=" << subject->getTemperature() << "℃，"
                      << "湿度=" << subject->getHumidity() << "%，"
                      << "风力=" << subject->getWind() << std::endl;
        }
    }

    std::string getName() const override { return name_; }
};

// 具体观察者2：电视屏幕
class TVScreen : public WeatherObserver {
private:
    std::string name_;
public:
    explicit TVScreen(std::string name) : name_(std::move(name)) {}

    void update(WeatherSubject* subject) override {
        if (subject) {
            std::cout << "[" << name_ << "] 刷新天气："
                      << "温度=" << subject->getTemperature() << "℃，"
                      << "湿度=" << subject->getHumidity() << "%，"
                      << "风力=" << subject->getWind() << std::endl;
        }
    }

    std::string getName() const override { return name_; }
};

// 5. 客户端代码：组装主题和观察者，模拟状态变化
int main() {
    // 创建具体主题（天气数据中心）
    std::shared_ptr<WeatherSubject> weatherCenter = std::make_shared<WeatherDataCenter>();

    // 创建具体观察者（手机APP、电视屏幕）
    std::shared_ptr<WeatherObserver> phone = std::make_shared<PhoneAPP>("小米手机APP");
    std::shared_ptr<WeatherObserver> tv = std::make_shared<TVScreen>("客厅电视");

    // 注册观察者
    weatherCenter->attach(phone);
    weatherCenter->attach(tv);

    // 模拟天气数据更新（触发通知）
    std::dynamic_pointer_cast<WeatherDataCenter>(weatherCenter)->setWeatherData(25.5, 60, "微风");

    // 移除一个观察者（手机APP），再更新数据
    weatherCenter->detach(phone);
    std::dynamic_pointer_cast<WeatherDataCenter>(weatherCenter)->setWeatherData(27.0, 55, "东风3级");

    return 0;
}
```



### 访问者模式



### 中介者模式



### 解释器模式

